#include <stdio.h>
#include <iostream>
#include <ctype.h>
using namespace std;
/* Global declarations */
/* Variables */
int charClass;
char lexeme[100];
char nextChar;
int lexLen;
int token;
int nextToken;
FILE *in_fp, *fopen();
/* Function declarations */
void addChar();
void getChar();
void getNonBlank();
void program();
void keyword();
void declare();
void declarident();
void stmts();
void assign();
void expr();
void funcname();
void ident();
int lex(); // Call lex
/* Character classes */
#define LETTER 0
#define UNKNOWN 99
/* Token codes */
#define IDENT 11
#define ASSIGN_OP 20
#define MULT_OP 21
#define DIV_OP 22
#define LEFT_PAREN 23
#define RIGHT_PAREN 24
#define LEFT_BRACE 25
#define RIGHT_BRACE 26
#define COMMA 27
#define SEMI_COLON 28
/******************************************************/
/* main driver */
int main() {
	/* Open the input data file and process its contents */
	cout<<"Which test program would you like to run?"
		<<" Test 1 (Enter 1) or Test 2 (Enter 2)"<<endl; // prompt user for which file to open
	int choice;
	cin>>choice;
	bool tf = true;
	while (tf) { // input validation
		switch(choice) {
		case 1:
			tf = false; // stop loop
			if ((in_fp = fopen("test1.txt", "r")) == NULL) // if error opening first file
				printf("ERROR - cannot open test1.txt \n"); //error opening file
			else {
				getChar(); // get first char
				do {
					//lex(); // Call lex
					program(); // check program against lexical
				} while (nextToken != EOF); // loop until EOF
			}
			break;
		case 2:
			tf = false; // stop loop
			if ((in_fp = fopen("test2.txt", "r")) == NULL) // if error opening second file
				printf("ERROR - cannot open test2.txt \n"); //error opening file
			else {
				getChar(); // get first char
				do {
					//lex(); // Call lex
					program(); // check program against lexical
				} while (nextToken != EOF);// loop until EOF
			}
			break;
		default:
			cout<<"Error. Invalid choice."<<endl; // reprompt user
			cout<<"Which test program would you like to run?"
				<<" Test 1 (Enter 1) or Test 2 (Enter 2)"<<endl;
			cin>>choice;
			break;
		}
	}
	system("pause");
}
/*****************************************************/
/* lookup - a function to lookup operators and parentheses
and return the token */
int lookup(char ch) {
	switch (ch) {
	case '(': // Left Parenthesis
		addChar();
		nextToken = LEFT_PAREN;
		break;
	case ')': // Right PArenthesis
		addChar();
		nextToken = RIGHT_PAREN;
		break;
	case '*': // Multiplication Operation
		addChar();
		nextToken = MULT_OP;
		break;
	case '/': // Division Operation
		addChar();
		nextToken = DIV_OP;
		break;
	case '=': // Assignment Operation
		addChar();
		nextToken = ASSIGN_OP;
		break;
	case '{': // Left Brace
		addChar();
		nextToken = LEFT_BRACE;
		break;
	case '}': // Right Brace
		addChar();
		nextToken = RIGHT_BRACE;
		break;
	case '\n': // New Line Character
		getChar();
		break;
	case '\t': // Tab Character
		getChar();
		break;
	case ',': // Comma
		addChar();
		nextToken = COMMA;
		break;
	case ';': // Semi-Colon
		addChar();
		nextToken = SEMI_COLON;
		break;
	default: // EOF
		addChar();
		nextToken = EOF;
		break;
	}
	return nextToken;
}
/*****************************************************/
/* addChar - a function to add nextChar to lexeme */
void addChar() {
	if (lexLen <= 98) {
		lexeme[lexLen++] = nextChar;
		lexeme[lexLen] = 0;
	}
	else
		printf("Error - lexeme is too long \n");
}
/*****************************************************/
/* getChar - a function to get the next character of
input and determine its character class */
void getChar() {
	if ((nextChar = getc(in_fp)) != EOF) {
		if (isalpha(nextChar))
			charClass = LETTER;
		else charClass = UNKNOWN;
	}
	else
		charClass = EOF;
}
/*****************************************************/
/* getNonBlank - a function to call getChar until it
returns a non-whitespace character */
void getNonBlank() {
	while (isspace(nextChar))
		getChar();
}
/*
*****************************************************/
/* lex - a simple lexical analyzer for arithmetic
expressions */
int lex() {
	lexLen = 0;
	getNonBlank();
	switch (charClass) {
		/* Parse identifiers */
	case LETTER:
		addChar();
		getChar();
		while (charClass == LETTER) {
			addChar();
			getChar();
		}
		nextToken = IDENT;
		break;
		/* Parentheses and operators */
	case UNKNOWN:
		lookup(nextChar);
		getChar();
		break;
		/* EOF */
	case EOF:
		nextToken = EOF;
		lexeme[0] = 'E';
		lexeme[1] = 'O';
		lexeme[2] = 'F';
		lexeme[3] = 0;
		break;
	} /* End of switch */
	printf("Next token is: %d, Next lexeme is %s\n",
		nextToken, lexeme);
	return nextToken;
} /* End of function lex */
/* program
Parses strings in the language generated by the rule:
<program> -> <keyword> <funcname>() { <declare> <stmts> }
*/
void program() {
	printf("Enter <program>\n");
	/* Parse the keyword */
	keyword();
	funcname();
	lex(); // Call lex
	if (nextToken == LEFT_PAREN) {
		lex(); // Call lex
		if (nextToken == RIGHT_PAREN) {
			lex(); // Call lex
			if (nextToken == LEFT_BRACE) {
				declare();
				stmts();
				lex(); // Call lex
				if (nextToken == RIGHT_BRACE) {
					printf("Exit <program>\n");
					lex(); // Call lex
					printf("The sample program is correct!\n");
				}
			}
		}
	}
}

/* keyword
Parses strings in the language generated by the rule:
<keyword> -> float
*/
void keyword() {
	printf("Enter <keyword>\n");
	lex(); // Call lex
	printf("Exit <keyword>\n");
}

/* declare
Parses strings in the language generated by the rule:
<declare> -> float <ident>;
	| float <ident>, <declarident>
*/
void declare() {
	printf("Enter <declare>\n");
	/* Parse the first identifier */
	lex(); // Call lex
	if (nextToken == IDENT) {
		ident();
		lex(); // Call lex
		if (nextToken == SEMI_COLON) {
			lex(); // Call lex
			printf("Exit <declare>\n");
		}
		else if (nextToken == COMMA) {
			declarident();
		}
	}
}

/* declarident
Parses strings in the language generated by the rule:
<declarident> -> <ident>, <declarident>
	| <ident>;
*/
void declarident() {
	printf("Enter <declarident>\n");
	ident();
	lex(); // Call lex
	if (nextToken == COMMA) {
		declarident();
	}
		printf("Exit <declarident>\n");
	
}

/* stmts
Parses strings in the language generated by the rule:
<stmts> -> <assign>; <assign>;
*/
void stmts() {
	printf("Enter <stmts>\n");
	assign();
	lex(); // Call lex
	if (nextToken == SEMI_COLON) {
		assign();
		lex(); // Call lex
		if (nextToken == SEMI_COLON) 
			printf("Exit <stmts>\n");
	}
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
void assign() {
	printf("Enter <assign>\n");
	ident();
	lex(); // Call lex
	if (nextToken == ASSIGN_OP) {
		expr();
		printf("Exit <assign>\n");
	}
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <ident> {* | /} <expr>
	| <ident>
*/
void expr() {
	printf("Enter <expr>\n");
	/* Parse the first identifier */
	ident();
	lex(); // Call lex

	/* As long as the next token is * or /, get the next token and parse the next term */
	while (nextToken == MULT_OP || nextToken == DIV_OP) {
		bool test = false;
		if (nextToken == DIV_OP) {
			test = true;
		}
		ident();
		if (!test)
		lex(); // Call lex
	}
	printf("Exit <expr>\n");
}

/* funcname
Parses strings in the language generated by the rule:
<funcname> -> <ident>
*/
void funcname() {
	printf("Enter <funcname>\n");
	if (nextToken == IDENT) {
	lex(); // Call lex
	}
	printf("Exit <funcname>\n");
}

/* ident
Parses strings in the language generated by the rule:
<ident> -> a <ident> | b <ident> | ... | z <ident> | (Epsilon)
*/
void ident() {
	printf("Enter <ident>\n");
	lex(); // Call lex // Call lex
	printf("Exit <ident>\n");
}